generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String         @id @default(uuid()) @db.Uuid
  steamId              String         @unique
  name                 String?
  avatar               String?
  profileUrl           String?
  email                String?        @unique
  walletBalance        Float          @default(0)
  bannedUntil          DateTime?
  tradeUrl             String?
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @default(now()) @updatedAt
  last_seen            DateTime?
  cartItems            CartItem[]
  notifications        Notification[]
  offers               Offer[]
  transactionsAsBuyer  Transaction[]  @relation("Buyer")
  transactionsAsSeller Transaction[]  @relation("Seller")
  isSoftBanned         Boolean        @default(false)
  bannedAt             DateTime?
  supportTickets       SupportTicket[]
  supportMessages      SupportMessage[]
  isAdmin              Boolean        @default(false) // Colonne existante pour les admins
  stripeCustomerId     String?        @unique // ID du customer Stripe pour les dépôts/retraits
  stripeAccountId      String?        @unique // ID du compte Stripe Connect pour les retraits
  stripeAccount        StripeAccount?
  stripeDeposits       StripeDeposit[]
  stripeWithdrawals    StripeWithdrawal[]
}

model Offer {
  id          String       @id @default(uuid()) @db.Uuid
  sellerId    String       @db.Uuid
  itemId      String
  itemName    String?
  itemImage   String?
  rarityCode  String?
  game        String?
  price       Float
  status      OfferStatus  @default(AVAILABLE)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @default(now()) @updatedAt
  expiresAt   DateTime?
  cartItems   CartItem[]
  seller      User         @relation(fields: [sellerId], references: [id])
  transaction Transaction?
}

model Transaction {
  id             String            @id @default(uuid()) @db.Uuid
  offerId        String            @unique @db.Uuid
  buyerId        String            @db.Uuid
  sellerId       String            @db.Uuid
  status         TransactionStatus
  escrowUntil    DateTime?
  escrowReleased Boolean           @default(false)
  refunded       Boolean           @default(false)
  refundReason   String?
  bannedSeller   Boolean           @default(false)
  transactionFee Float             @default(0) // Frais de transaction (en EUR)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @default(now()) @updatedAt

  offer      Offer       @relation(fields: [offerId], references: [id])
  buyer      User        @relation("Buyer", fields: [buyerId], references: [id])
  seller     User        @relation("Seller", fields: [sellerId], references: [id])
  escrowLogs EscrowLog[]
}

model EscrowLog {
  id            String      @id @default(uuid()) @db.Uuid
  transactionId String      @db.Uuid
  action        String
  details       String?
  createdAt     DateTime    @default(now())
  transaction   Transaction @relation(fields: [transactionId], references: [id])
}

model Notification {
  id        String           @id @default(uuid()) @db.Uuid
  userId    String           @db.Uuid
  type      NotificationType
  title     String
  message   String
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id])
}

model CartItem {
  id      String   @id @default(uuid()) @db.Uuid
  userId  String   @db.Uuid
  offerId String   @db.Uuid
  addedAt DateTime @default(now())
  user    User     @relation(fields: [userId], references: [id])
  offer   Offer    @relation(fields: [offerId], references: [id])

  @@index([offerId])
  @@index([userId])
}

model SupportTicket {
  id          String           @id @default(uuid()) @db.Uuid
  userId      String           @db.Uuid
  subject     String
  status      TicketStatus     @default(OPEN)
  priority    String           @default("MEDIUM") // Type text pour correspondre à Supabase
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @default(now()) @updatedAt
  messages    SupportMessage[]
  user        User             @relation(fields: [userId], references: [id])
}

model SupportMessage {
  id          String           @id @default(uuid()) @db.Uuid
  ticketId    String           @db.Uuid
  senderId    String           @db.Uuid
  senderRole  SupportRole      // 'USER' ou 'ADMIN'
  content     String
  createdAt   DateTime         @default(now())
  ticket      SupportTicket    @relation(fields: [ticketId], references: [id])
  sender      User             @relation(fields: [senderId], references: [id])
}

model InventoryCache {
  id        String   @id @default(cuid())
  steamId   String   @unique
  data      Json     // Stockage des données d'inventaire
  updatedAt DateTime @default(now())
  gameId    String   // Pour différencier les jeux (730, 570, etc.)
  currency  String   // Pour différencier les devises (EUR, USD, etc.)

  @@unique([steamId, gameId, currency])
  @@index([steamId])
  @@index([updatedAt])
}

model StripeAccount {
  id                    String   @id @default(uuid()) @db.Uuid
  userId                String   @unique @db.Uuid
  stripeAccountId       String   @unique
  businessProfile       Json?    // Données du business profile
  requirements          Json?    // Requirements Stripe
  chargesEnabled        Boolean  @default(false)
  payoutsEnabled        Boolean  @default(false)
  detailsSubmitted      Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @default(now()) @updatedAt
  
  user                  User     @relation(fields: [userId], references: [id])
}

model StripeDeposit {
  id                    String   @id @default(uuid()) @db.Uuid
  userId                String   @db.Uuid
  stripePaymentIntentId String   @unique
  stripeSessionId       String?  @unique
  amount                Int      // Montant en centimes
  currency              String   @default("eur")
  status                String   @default("pending") // pending, succeeded, failed
  walletCredited        Boolean  @default(false) // Si le wallet a été crédité
  createdAt             DateTime @default(now())
  updatedAt             DateTime @default(now()) @updatedAt
  
  user                  User     @relation(fields: [userId], references: [id])
}

model StripeWithdrawal {
  id                    String   @id @default(uuid()) @db.Uuid
  userId                String   @db.Uuid
  stripeTransferId      String?  @unique
  amount                Int      // Montant en centimes
  currency              String   @default("eur")
  status                String   @default("pending") // pending, succeeded, failed
  walletDebited         Boolean  @default(false) // Si le wallet a été débité
  createdAt             DateTime @default(now())
  updatedAt             DateTime @default(now()) @updatedAt
  
  user                  User     @relation(fields: [userId], references: [id])
}

enum OfferStatus {
  AVAILABLE
  PENDING_TRADE_OFFER
  COMPLETED
  EXPIRED
}

enum TransactionStatus {
  PENDING
  IN_ESCROW
  RELEASED
  REFUNDED
  CANCELLED
}

enum NotificationType {
  OFFER_CREATED
  OFFER_SOLD
  OFFRE_CANCELLED
  TRANSACTION_STARTED
  TRANSACTION_COMPLETED
  REMINDER
  PENALTY
  CONFIRM
}

enum TicketStatus {
  OPEN
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
}

enum SupportRole {
  USER
  ADMIN
}
